import DS from 'ember-data';
import fetch from 'fetch';
import ENV from '../config/environment';
import { isInDom } from '../lib/alien-dom';
import { canonicalize } from 'wnyc-web-client/services/script-loader';

export default DS.Adapter.extend({
  findRecord(store, type, id /*, snapshot */) {
    if (isInDom(id)) {
      return document;
    }

    // django-page requests can be root-relative since we're always serving from our own domain
    // except if the request is to the index route; in dev mode this will fail,
    // since it always returns the index page. forcing the domain gets the html
    // we want.
    let url = '/';
    if (id === '/') {
      if (ENV.betaTrials.isBetaSite) {
        url = ENV.wnycBetaURL;
      } else {
        url = ENV.wnycURL;
      }
    } else if (ENV.environment === 'test') {
      url = ENV.wnycURL;
    }

    return fetch(`${canonicalize(url)}${id === '/' ? '' : id}`, { headers: {'X-WNYC-EMBER':1}})
      .then(checkStatus)
      .then(response => response.text());
  },
  // starting in ember-data 2.0, this defaults to true
  // http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-adapter-hooks-for-better-caching
  // ember-wormhole is the crux of our page render paradigm, and it relies on
  // element IDs which are generated by the model at run-time; reloading the model
  // in the background recomputes all the embeddedWnycComponent CPs, which causes
  // ember-wormhole to barf due to differences between the rendered IDs and the
  // model element's new IDs
  shouldBackgroundReloadRecord: () => false
});

function checkStatus(response) {
  if (response.status >= 200 && response.status < 300) {
    return response;
  } else {
    var error = new Error(response);
    error.response = response;
    throw error;
  }
}
